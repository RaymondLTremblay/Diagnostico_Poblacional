# Compadre_Orchid PPM y su uso

## Raymond y Roberto



```{r}
library(Rcompadre)
library(tidyverse)
library(gt)
library(kableExtra)
```
```{r, echo=FALSE}
library(tidyverse)

rlt_theme <- theme(axis.title.y = element_text(colour="grey20",size=15,face="bold"),
        axis.text.x = element_text(colour="grey20",size=10, face="bold"),
        axis.text.y = element_text(colour="grey20",size=15,face="bold"),  
        axis.title.x = element_text(colour="grey20",size=15,face="bold"))+
  theme(
  # Remove panel border
  panel.border = element_blank(),  
  # Remove panel grid lines
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  # Remove panel background
  panel.background = element_blank(),
  # add thicker border lines
    axis.line.x = element_line(colour = "black", size = 1),
    axis.line.y = element_line(colour = "black", size = 1)
  )

# The palette with grey:
cbPalette1 <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# The palette with black:
cbPalette2 <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# To use for fills, add
#  scale_fill_manual(values=cbPalette)

# To use for line and point colors, add
  #scale_colour_manual(values=cbPalette)

```

## Load data from **COMPADRE**

```{r}

#load("~/Library/CloudStorage/Dropbox/GitHub_Dropbox_Drive/GitHub/Diagnostico_Poblacional/Diagnostico_Poblacional/COMPADRE_v.6.23.5.0.RData")

load("~/Dropbox/GitHub_Dropbox_Drive/GitHub/Diagnostico_Poblacional/Diagnostico_Poblacional/COMPADRE_v.6.23.5.0.RData") # work computer

ALLSp=as_cdb(compadre)  # Un paso critico: Convertir la base de datos anterior COM(P)ADRE (de clase 'list') en la base en un objeto CompadreDB.

names(ALLSp) # Nombre de las variables


index_O=ALLSp %>% 
 filter(Family %in% c("Orchidaceae")) # Extraer la orquídeas de la base de datos. 



```


## Lista de especies de orquídeas en la base de datos de COPADRE 

```{r}
unique(index_O$SpeciesAccepted)
index_O
unique(index_O$DOI_ISBN)

unique(index_O$Authors)
```



## How many unique studies?

To know how long the studies were and be unique I need to select combinations of variables that make it unique.

Subset 

```{r}
names(index_O)
SPECIES_O=index_O %>% select(StudyStart, StudyEnd, SpeciesAccepted, YearPublication, Authors, DOI_ISBN, OrganismType, MatrixPopulation,mat) %>% 
  group_by(SpeciesAccepted, YearPublication, Authors, DOI_ISBN, OrganismType, StudyStart, StudyEnd) %>% 
  summarize(n_populations = length(unique(MatrixPopulation))) %>% 
  arrange(desc(n_populations)) %>% 
  mutate(StudyStart=as.numeric(StudyStart)) %>% 
  mutate(StudyEnd=as.numeric(StudyEnd)) %>% 
  drop_na(StudyStart, StudyEnd)

SPECIES_O %>% kable()


write_csv(SPECIES_O, "Species_O.csv")
```



# Number of populations per species study 



```{r}
as.data.frame(table(SPECIES_O$n_populations))


```



```{r}

SPECIES_O$SpeciesAccepted <- fct_reorder(SPECIES_O$SpeciesAccepted, SPECIES_O$StudyStart, .desc = FALSE)

ggplot(SPECIES_O, aes(SpeciesAccepted, color=OrganismType))+
  geom_linerange(aes(x= SpeciesAccepted  , ymin=StudyStart, ymax=StudyEnd))+
  coord_flip()+
  theme(legend.position = c(0.2, 0.8))+
  ylab("")+
  xlab("")+
  rlt_theme+
  theme(axis.text.x = element_text(color = "grey20", size = 9, angle = 90, hjust = .5, vjust = .5, face = "plain"),
        axis.text.y = element_text(color = "grey20", size = 7, angle = 0, hjust = 1, vjust = 0, face = "plain"),  
        axis.title.x = element_text(color = "grey20", size = 12, angle = 0, hjust = .5, vjust = 0, face = "plain"),
        axis.title.y = element_text(color = "grey20", size = 12, angle = 90, hjust = .5, vjust = .5, face = "plain"))


ggsave("Lenght_survey.png")

```





```{r}

index_O=index_O %>% 
  mutate(StudyDuration=as.numeric(StudyDuration))

table(index_O$StudyDuration)
table(index_O$OrganismType)

ggplot(index_O, aes(StudyDuration, fill=OrganismType))+
         geom_histogram(colour="white")+
  facet_wrap(~OrganismType)+
  theme(legend.position = "none")+
  xlab("Study duration")+
  ylab("Frequency")+
  rlt_theme

#ggsave("Duración_Epi_Ter.pdf")

ggsave("Duración_Epi_Ter.png")
```




```{r}
plot(index_O$Lon,index_O$Lat,main = "Location")
```



Getting the whole database for orchids



```{r}

index <- which(compadre$metadata$Family=="Orchidaceae") 
names(Compadre)

subset(index_O, Family =="Orchidaceae"  &
             MatrixDimension >2)


subset(index_O,DicotMonoc == "Eudicot" & 
              Country %in% c("USA", "CAN") & 
              MatrixDimension > 2)

#cdb_compare(index_O,x)


x <- subset(index_O,Family == "Orchidaceae")

x_OT=x %>% 
  group_by(OrganismType)
```


```{r}
#Orchids_New=as_cdb(index)
#compadre$mat[index]

Compadre_flagged <- cdb_flag(index_O)

x <- subset(Compadre_flagged, check_NA_A == FALSE & check_ergodic == TRUE)
x
y <- subset(Compadre_flagged, check_NA_A == FALSE & check_irreducible == TRUE)

y
xy <- subset(Compadre_flagged, check_NA_A == FALSE & check_irreducible == TRUE & check_ergodic == TRUE)
xy

lambdaVals <- sapply(matA(xy), popdemo::eigs, what="lambda")
summary(lambdaVals)
hist(lambdaVals, main = "Lambda values")
```



```{r}

library(purrr)
lambdaVals1 <- map_dbl(matA(xy), ~popdemo::eigs(.x, what="lambda"))
 
 
#Or with popbio, which avoids some warning messages…
lambdaVals2 <- map_dbl(matA(xy), ~popbio::lambda(.x))
```

```{r}
x2=xy %>% 
  mutate(OrganismType = case_when(
    Genus ==  "Caladenia" & OrganismType == "Epiphyte" ~ "Herbaceous perennial",
    TRUE ~ OrganismType
  ))

epi=x2 %>% 
  filter(OrganismType=="Epiphyte")

terr=x2 %>% 
  filter(OrganismType=="Herbaceous perennial")



```

Compadre_flagged <- cdb_flag(index_O)

x <- subset(Compadre_flagged, check_NA_A == FALSE & check_ergodic == TRUE)

lambdaVals <- sapply(matA(x), popdemo::eigs, what="lambda")
summary(lambdaVals)
hist(lambdaVals, main = "Lambda values")


```{r}

Compadre_flagged_epi <- cdb_flag(epi)

x_epi <- subset(Compadre_flagged_epi, check_NA_A == FALSE & check_ergodic == TRUE)

#sapply(matA(x_epi), popdemo::eigs, what="lambda")

library(purrr)
lambda_epi <- map_dbl(matA(x_epi), ~popdemo::eigs(.x, what="lambda"))

#Or with popbio, which avoids some warning messages…
lambda_terr <- map_dbl(matA(terr), ~popbio::lambda(.x))
```

```{r}
summary(lambda_epi)
hist(lambda_epi, main = "Lambda values")

summary(lambda_terr)
hist(lambda_terr, main = "Lambda values")
```

```{r}
df_Lamb_epi=as.data.frame(lambda_epi)
df_Lamb_epi=df_Lamb_epi %>% 
  add_column(Habit_Type = "Epiphyte") %>% 
  rename(lambda=lambda_epi)


df_Lamb_terr=as.data.frame(lambda_terr)
df_Lamb_terr=df_Lamb_terr %>% 
  add_column(Habit_Type = "Terrestrial")%>% 
  rename(lambda=lambda_terr)


ALL_Lambdas=rbind(df_Lamb_epi, df_Lamb_terr)
```

```{r}
ggplot(ALL_Lambdas, aes(lambda, fill=Habit_Type ))+
  geom_histogram(colour="white") + 
  facet_wrap( ~Habit_Type)+
  rlt_theme

ggsave("Terr_Epi_lambda.png")
```





The number of populations 


```{r}
x2 %>% 
  group_by(SpeciesAccepted) %>% 
  summarize(n_populations = length(unique(MatrixPopulation))) %>% 
  arrange(desc(n_populations))
```




```{r}

compadre_replicated_pops <- x2 %>% 
  group_by(SpeciesAccepted) %>% 
  mutate(n_pops = length(unique(MatrixPopulation))) %>% 
  ungroup() %>%
  subset(n_pops >= 10)

compadre_replicated_pops
```


```{r}
ggplot2::ggplot(x2, aes(Lon, Lat)) +
  borders(database = "world", fill = "grey80", col = NA) +
  geom_point(col = "steelblue", size = 1.8, alpha = 0.8)
```


## Important to include only matrices that are annual.   

Unless we data wrangle the life span so it represent a year worth instead of life span.




```{r}
# function to calculate life expectancy
lifeExpectancy <- function(matU, startLife) {
  N <- solve(diag(nrow(matU)) - matU)
  return(colSums(N)[startLife])
}

compadre_life_expect <- x2 %>% 
  filter(ProjectionInterval >0.999) |> 
  filter(MatrixComposite == "Mean", # filter is the dplyr version of subset
         MatrixTreatment == "Unmanipulated",
         MatrixCaptivity == "W",
         #ProjectionInterval == "1"
         ) %>% 
  mutate(StageID = cdb_id_stages(.)) %>%
  cdb_collapse(columns = "StageID") %>%
  cdb_flag() %>% 
  filter(check_NA_U == FALSE,
         check_zero_U == FALSE,
         check_singular_U == FALSE) %>% 
  mutate(matU = matU(.), start_life = mpm_first_active(.)) %>% 
  mutate(life_expectancy = mapply(lifeExpectancy, matU, start_life)) %>% 
 # filter(life_expectancy >= 1) %>% 
  mutate(OrganismType = reorder(OrganismType, life_expectancy, median))

ggplot2::ggplot(compadre_life_expect, aes(OrganismType, life_expectancy)) +
  geom_boxplot() +
  scale_y_log10() +
  coord_flip() +
  labs(x = NULL, y = "Life expectancy (years)")+
  rlt_theme

ggsave("Life_Span.png")
```


Test difference in life span.


```{r}
unique(compadre_life_expect$OrganismType)

t.test(life_expectancy~OrganismType, data=compadre_life_expect)


shapiro.test(compadre_life_expect$life_expectancy) # Not normaly distributed


library(car)

leveneTest(life_expectancy~OrganismType, data=compadre_life_expect) # equal variance but not notmaly distributed

```


Use robust Approach


```{r}
library(WRS2)
#source("/Users/rlt/Dropbox/METAS+COHORT_D/Rallfun-v38.txt", chdir = T)
#source("/Users/rlt/Dropbox/Ackermanstuff/Pollinator_Interaction/Specificity_Index_pollinators/Rallfun-v38.txt", chdir = T) ## Work laptop Computer
source("/Users/raymondtremblay/Dropbox/METAS+COHORT_D/Rallfun-v38.txt", chdir = T) #When used on Monique
```



```{r}
unique(compadre_life_expect$OrganismType)

Cf=cdb_flatten(compadre_life_expect)


YSEC_T=Cf %>% 
  dplyr::select("life_expectancy", "OrganismType") %>% 
  filter(OrganismType== "Herbaceous perennial")

YSEC_T
YSEC_E=Cf %>% 
  dplyr::select("life_expectancy", "OrganismType") %>% 
  filter(OrganismType== "Epiphyte")

yuenbt(YSEC_T$life_expectancy, YSEC_E$life_expectancy, alpha=.05, nboot=10000, side=T)

```






```{r}
library(Rcompadre)
library(popdemo)
data(Compadre)


Compadre$matA <- matA(Compadre)

# create empty vector to store output
Compadre$dim <- numeric(nrow(Compadre))

index$dim <- numeric(nrow(index_O))

# loop through all rows of Compadre
for (i in seq_len(nrow(Compadre))) {
  Compadre$dim[i] <- nrow(Compadre$matA[[i]])
}

# function to determine whether matrix 'mat' has any stages with no transitions
NullStages <- function(mat) any(colSums(mat) == 0)

# apply function to every element of A
Compadre$null_stages <- sapply(Compadre$matA, NullStages)

NullStages(Compadre$matA[[1]]) # apply function to single element
Compadre$null_stages <- sapply(matA(Compadre), NullStages)
```

